= Setup =

== Create your processing module ==
The documentation generation use annotation processing. Wikbook module only provide an abstract processig : AbstractTemplateProcessor
In this module you will extend the abstract processor and write your templates.

You need to use wikbook/template/core module :
{{example title="Maven wikbook dependency"}}
{{code language=xml}}
<dependency>
  <groupId>org.wikbook</groupId>
  <artifactId>wikbook.template.core</artifactId>
  <version>0.9.33</version>
</dependency>
{{/code}}
{{/example}}

== Create your processor ==
Don't freak out, your processor will not be a full processor. All the processing will be done by AbstractTemplateProcessor, you only have to configure it.

The requited values data are :
* Processed annotations as Class[]
* Template name as String
* Output directory as String
* Generated extension as String (only used for file name)

{{example title="Typical jaxrs processor"}}
{{code language=java}}{@include org.wikbook.doc.JaxrsTemplateProcessor}{{/code}}
{{/example}}

{{example title="Typical chromattic processor"}}
{{code language=java}}{@include org.wikbook.doc.ChromatticTemplateProcessor}{{/code}}
{{/example}}

== Enable processing with service ==
To enable your processors as service just create the following file :
{{example title="META-INF/services/javax.annotation.processing.Processor"}}
{{code}}
org.wikbook.doc.JaxrsTemplateProcessor
org.wikbook.doc.ChromatticTemplateProcessor
{{/code}}
{{/example}}

{{important}}You can have only one processor.{{/important}}

== Create your template ==
Each processor will use a template. A section is dedicated to these templates.

== Package template with classifier ==
To be able to use the templates during the processing, you have to package yours templates with a classifier (we will use "templates" classifier).

{{example title="Package templates with maven"}}
{{code language=xml}}
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-jar-plugin</artifactId>
      <executions>
        <execution>
          <phase>package</phase>
          <goals>
            <goal>jar</goal>
          </goals>
          <configuration>
            <classifier>templates</classifier>
            <includes>
              <include>**/templates/*</include>
            </includes>
          </configuration>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
{{/code}}
{{/example}}

== Generate ! ==

Now you are ready to generate the documentation of existing module. Since you have declared your processors as service, just add it to classpath.
You need to add some maven configuration to perform some stuff like unpack templates, use it, and package the generated files.

{{example title="Add your processors to the classpath"}}
{{code language=xml}}
<dependency>
  <groupId>my.group.id</groupId>
  <artifactId>my.artifact.id</artifactId>
  <scope>compile</scope>
  <optional>true</optional>
</dependency>

<dependency>
  <groupId>my.group.id</groupId>
  <artifactId>my.artifact.id</artifactId>
  <classifier>templates</classifier>
</dependency>
{{/code}}
{{/example}}

{{example title="Unpack your templates and use it"}}
{{code language=xml}}
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-dependency-plugin</artifactId>
  <version>2.1</version>
  <executions>
    <execution>
      <id>unpack-templates</id>
      <phase>generate-sources</phase>
      <goals>
        <goal>unpack-dependencies</goal>
      </goals>
      <configuration>
        <includeGroupIds>org.exoplatform.social</includeGroupIds>
        <includeArtifactIds>exo.social.docs.gen</includeArtifactIds>
        <includeClassifiers>templates</includeClassifiers>
        <excludes>META-INF/**</excludes>
        <outputDirectory>${project.build.directory}/templates</outputDirectory>
      </configuration>
    </execution>
  </executions>
</plugin>

<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <version>2.3.2</version>
  <executions>
    <execution>
      <id>default-compile</id>
      <goals>
        <goal>compile</goal>
      </goals>
      <phase>compile</phase>
      <configuration>
        <compilerArguments>
          <sourcepath>${project.build.directory}/templates</sourcepath>
        </compilerArguments>
      </configuration>
    </execution>
  </executions>
</plugin>
{{/code}}
{{/example}}

{{example title="Package generated files"}}
{{code language=xml}}
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-jar-plugin</artifactId>
  <executions>
    <execution>
      <phase>package</phase>
      <goals>
        <goal>jar</goal>
      </goals>
      <configuration>
        <classifier>doc-generated</classifier>
        <includes>
          <include>**/generated/*</include>
        </includes>
      </configuration>
    </execution>
  </executions>
</plugin>
{{/code}}
{{/example}}

= Templates =
Each type which are annoted by one processed annotation will generate a file.
When a file is generated the template is applied. In the template you can print and browse the annotation.
Freemarker is used as template engine, that means you can use all freemarker feature like loop or conditional structure.
Please have a look to the freemarker documentaton : http://freemarker.sourceforge.net/docs

In the template you can do simple actions like print type name, element name, but you can also do more complex operations like get children, get sibling, get the javadoc and more things.

== Root elements ==
The root data are the annotation name like "@Path" for jaxrs using. Only the type annotations are considered as root data.

== Annotation name ==
To print the annotation name you can use "name" property.
{{example title="Simple annotation name"}}
|Code|((({{code language=java}}
@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
Name : ${@Annotation.name}
{{/code}})))
|Output|(((
{{code}}
Name : Annotation
{{/code}})))
{{/example}}

Actually this time we already know the name, but sometimes it can be useful (when you don't know which annotation you are working on).

== Element name ==
It's the element's name. It can be the class name, method name, or parameter name which are annoted by the current annotation.

{{example title="Class element name"}}
|Code|((({{code language=java}}
@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
Name : ${@Annotation.elementName}
{{/code}})))
|Output|(((
{{code}}
Name : A
{{/code}})))
{{/example}}

{{example title="Method element name"}}
|Code|((({{code language=java}}
// ...
  @Annotation
  String m() { /* ... */ }
// ...
{{/code}})))
|Template|(((
{{code}}
// ...
Name : ${a.elementName}
// ...
{{/code}})))
|Output|(((
{{code}}
// ...
Name : m
// ...
{{/code}})))
{{/example}}

{{example title="Parameter element name"}}
|Code|((({{code language=java}}
// ...
  String m(@Annotation String p) { /* ... */ }
// ...
{{/code}})))
|Template|(((
{{code}}
// ...
Name : ${a.elementName}
// ...
{{/code}})))
|Output|(((
{{code}}
// ...
Name : p
// ...
{{/code}})))
{{/example}}

== Type ==
The type property have many values and provide a way to get more things about the type. It returns type, parameter type.

{{example title="Class type values"}}
|Code|((({{code language=java}}
package p;

@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
Name : ${@Annotation.type.name}
Full name : ${@Annotation.type.fullName}
Is array : ${@Annotation.type.isArray}
{{/code}})))
|Output|(((
{{code}}
Name : A
Full name : p.A
Is array : false
{{/code}})))
{{/example}}

{{example title="Method type values"}}
|Code|((({{code language=java}}
// ...
  @Annotation
  String[] m() { /* ... */ }
// ...
{{/code}})))
|Template|(((
{{code}}
// ...
Name : ${a.type.name}
Full name : ${a.type.fullName}
Is array : ${a.type.isArray}
// ...
{{/code}})))
|Output|(((
{{code}}
// ...
Name : String[]
Full name : java.lang.String[]
Is array : true
// ...
{{/code}})))
{{/example}}

{{example title="Parameter type values"}}
|Code|((({{code language=java}}
// ...
  Integer[] m(@Annotation String p) { /* ... */ }
// ...
{{/code}})))
|Template|(((
{{code}}
// ...
Name : ${a.type.name}
Full name : ${a.type.fullName}
Is array : ${a.type.isArray}
// ...
{{/code}})))
|Output|(((
{{code}}
// ...
Name : String
Full name : java.lang.String
Is array : false
// ...
{{/code}})))
{{/example}}

== Javadoc ==
The javadoc is accessible with the "doc" property.

=== General Javadoc ===

{{example title="Class or method general documentation"}}
|Code|((({{code language=java}}
/**
 * This is
 * the documentation.
 */
@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
Documentation : ${@Annotation.doc()}
{{/code}})))
|Output|(((
{{code}}
Documentation : This is the documentation.
{{/code}})))
{{/example}}

You can use doc() for class or method documentation.
You can also get the javadoc from a parameter. In this case you have only default javadoc which are corresponding do the parameter's javadoc

{{example title="Parameter documentation"}}
|Code|((({{code language=java}}
// ...
  /**
   * General method documentation.
   * 
   * @param p The parameter documentation
   */
  Integer m(@Annotation String p) { /* ... */ }
// ...
{{/code}})))
|Template|(((
{{code}}
// ...
Documentation : ${a.doc()}
// ...
{{/code}})))
|Output|(((
{{code}}
// ...
Documentation : The parameter documentation
// ...
{{/code}})))
{{/example}}

=== Javadoc with one key ===
You can get a specific documentation part like "author" in this way :

{{example title="Get the author"}}
|Code|((({{code language=java}}
/**
 * This is the documentation.
 *
 * @author foo
 */
@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
Documentation : ${@Annotation.doc()}
Author : ${@Annotation.doc("author")}
{{/code}})))
|Output|(((
{{code}}
Documentation : This is the documentation.
Author : foo
{{/code}})))
{{/example}}

=== Javadoc with many keys ===

Sometimes the documentation can have many times the same key. You can either iterate on each key, or ask wikbook to display all items.

{{example title="Use 'flat' prefix to display all values separated by coma"}}
|Code|((({{code language=java}}
/**
 * This is the documentation.
 *
 * @author foo
 * @author bar
 */
@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
Documentation : ${@Annotation.doc()}
Authors : ${@Annotation.doc("flat:author")}
{{/code}})))
|Output|(((
{{code}}
Documentation : This is the documentation.
Authors : foo, bar
{{/code}})))
{{/example}}

{{example title="Use 'list' prefix to make iteration possible"}}
|Code|((({{code language=java}}
/**
 * This is the documentation.
 *
 * @author foo
 * @author bar
 */
@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
<#list @Annotation.doc("list:author") as author>
Author : ${author}
</#list>
{{/code}})))
|Output|(((
{{code}}
Author : foo
Author : bar
{{/code}})))
{{/example}}

=== Get documentation as block ===

You could need to keep the documentation as it. For exemple you could wish to store some exemple without remove formatting.

{{example title="Use 'block' prefix to keep formatting"}}
|Code|((({{code language=java}}
/**
 * This is the documentation.
 *
 * @exemple
 * class A {
 *   // Here there is the code
 * }
 }
 */
@Annotation
class A {}
{{/code}})))
|Template|(((
{{code}}
Code :
${@Annotation.doc("bloc:exemple")}
{{/code}})))
|Output|(((
{{code}}
Code :
class A {
  // Here there is the code
}
{{/code}})))
{{/example}}

== Browse children ==

Each annotation allow to get children annotations. You just need to provide what annotation you are looking for and iterate.
You can also set many param to look for many annotations in the same browsing.

{{example title="Browse children"}}
|Code|((({{code language=java}}
@Annotation
class A {

  @A
  void m() {}

  @B
  void m2() {}
  
  @A
  void m3() {}
  
}
{{/code}})))
|Template|(((
{{code}}
Annoted by @A :
<#list @Annotation.children("@A") as a>
Method : ${a.elementName}
</#list>

Annoted by @A or @B :
<#list @Annotation.children("@A", "@B") as ab>
Method : ${ab.elementName} (${ab.name})
</#list>
{{/code}})))
|Output|(((
{{code}}
Annoted by @A:
Method : m
Method : m3

Annoted by @A or @B :
Method : m (A)
Method : m2 (B)
Method : m3 (A)
{{/code}})))
{{/example}}

== Get sibling ==

Each annotation can reach a sibling annotations.

{{example title="Get sibiling"}}
|Code|((({{code language=java}}
// ...
  @A
  @B
  void m() {}
// ...
{{/code}})))
|Template|(((
{{code}}
// ...
Name : ${a.name}
Sibling @B : ${a.sibling("@B").name}
// ...
{{/code}})))
|Output|(((
{{code}}
// ...
Name : A
Sibling @B : B
// ...
{{/code}})))
{{/example}}

After got sibling annotation you can reach the attribute then (see next section)

== Get attributes ==

The attribute method allow to enter inside the annotation to get any contained value by the annotation.
To use it you only have to call "attribute" method with member name. Don't forget that the default value name is "value".

{{example title="Get simple value"}}
|Code|((({{code language=java}}
@Annotation("foo", name = "bar")
class A {}
{{/code}})))
|Template|(((
{{code}}
Value : ${@Annotation.attribute("value")}
Name : ${@Annotation.attribute("name")}
{{/code}})))
|Output|(((
{{code}}
Name : foo
Value : bar
{{/code}})))
{{/example}}

Some annotation can have more complex value like array, you can print or iterate on it.

{{example title="Get array value"}}
|Code|((({{code language=java}}
@Annotation({"foo", "bar"})
class A {}
{{/code}})))
|Template|(((
{{code}}
Values : ${@Annotation.attribute("flat:value")}

or

<#list @Annotation.attribute("list:value") as v>
Value : ${v}
</#list>
{{/code}})))
|Output|(((
{{code}}
Values : foo, bar

or

Value : foo
Value : bar
{{/code}})))
{{/example}}

An annotation can also contains another nested annotation. Let use attribute in the same way to get it.

{{example title="Get annotation value"}}
|Code|((({{code language=java}}
@Annotation(@B("foo", name = "bar"))
class A {}
{{/code}})))
|Template|(((
{{code}}
Value : ${@Annotation.attribute("value").attribute("value")}
Name : ${@Annotation.attribute("value").attribute("name")}
{{/code}})))
|Output|(((
{{code}}
Value : foo
Name : bar
{{/code}})))
{{/example}}

{{example title="Get array annotation value"}}
|Code|((({{code language=java}}
@Annotation({@B("foo"), @B("bar")})
class A {}
{{/code}})))
|Template|(((
{{code}}
<#list ${Annotation.attribute("value") as sub}
Value : ${sub.attribute("value")}
</#list>
{{/code}})))
|Output|(((
{{code}}
Value : foo
Value : bar
{{/code}})))
{{/example}}